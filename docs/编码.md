# Encoding  

[简单消息](##简单消息)  
[Base 128 Varints](##Base\ 128\ Varints)  
[消息结构](##消息结构)  
[更多变量类型](##更多变量类型)  
[嵌入类型](##嵌入类型)  
[可选和重复元素](##可选和重复元素)  
[字段排序](##字段排序)  

本文介绍protocol buffer消息二进制传输格式。在应用程序中使用protocol buffer时，你并不需要了解这些，但它对你了解protocol buffer格式如何影响你的编码消息的大小很有用。  

## 简单消息  

我们从一个非常简单的消息定义开始：  

```proto
message Test1 {
  int32 a = 1;
}
```  

在程序中，你可以创建一个`Test1`，然后设置`a`为150。之后你讲消息序列化到一个输出流。如果你想检查编码的消息，你会看到三个字节：  

```text
08 96 01
```  

那么，这些数字代表什么呢？接着往下看。  

## Base 128 Varints  

要了解简单的protocol buffer编码。首先你要了解*varints*。Varints是使用一个或多个字节序列化整数的一种方法。数字越小，占用的字节越少。  

Varint中除最后一个字节外的的每个字节，都设置了*最高有效位（most significant bit, msb）* -- 这表明还有更多的字节要处理。每个字节的低7位用来存储以7位为一组的数字的补码表示形式，**最不重要的一组优先**。  

例如，数字1 -- 单个字节，所以msb未设置：  

```text
0000 00001
```  

数字300，更复杂的一个bit：  

```text
1010 1100 0000 0010
```  

你如何知道它是300呢？首先，从每个字节中删除msb，因为它只是用来告诉我们是否已经到达数字的末尾(如您所见，它是在第一个字节中设置的，因为varint中有多个字节)：  

```text
1010 1100 0000 0010
→ 010 1100  000 0010
```  

取反这两组7bit是，因为Varints先存储最不重要的有效组。然后把它们串联起来就得到你的最终值：  

```text
000 0010  010 1100
→  000 0010 ++ 010 1100
→  100101100
→  256 + 32 + 8 + 4 = 300
```  

## 消息结构  

如你所见，protocol buffer消息是一系列的键值对。消息的二进制版本只是用字段序号作为键 -- 字段的名称和类型只能通过引用消息类型的定义（`.proto`文件）来解码。  

消息编码时，键和值被串联到字节流中。消息解码时，解析者需要能忽略掉不能识别的字段。这样，新的字段可以在不破坏不能识别它们的旧程序的情况下添加到消息中。为此，在传输格式中的消息的“键”有两部分：`.proto`文件中的字段序号，和一个*wire类型*，它仅提供足够找到下列值的长度的信息。在大多数语言的实现中，这个键作为tag使用。  

可用的wire类型如下：  

| Type  |       意义       |                           用途                           |
| :---: | :--------------: | :------------------------------------------------------: |
|   0   |      Varint      | int32, int64, uint32, uint64, sint32, sint64, bool, enum |
|   1   |      64-bit      |                fixed64, sfixed64, double                 |
|   2   | Length-delimited | string, bytes, embedded messages, packed repeated fields |
|   3   |   Start group    |                   groups (deprecated)                    |
|   4   |    End group     |                   groups (deprecated)                    |
|   5   |      32-bit      |                 fixed32, sfixed32, float                 |  

在流式消息中，每个键都是一个包含`(field_number << 3) | wire_type`值得varint -- 换句话说，数字的最后三位存储wire类型。  

现在我们再来看看我们的例子。现在你知道流中的第一个数总是varint键，这里它是08，或（丢弃msb）：  

```text
000 1000
```  

最后3个bit是wire类型（0），然后再右移3位得到字段序号（1）。现在你知道字段序号是1，之后的值是varint。使用从上面得到的varint解码知识，我们可以得出下2位存着值150。  

```text
96 01 = 1001 0110  0000 0001
       → 000 0001  ++  001 0110 (drop the msb and reverse the groups of 7 bits)
       → 10010110
       → 128 + 16 + 4 + 2 = 150
```  

## 更多变量类型  

### 单个整数

## 嵌入类型  

## 可选和重复元素  

## 字段排序